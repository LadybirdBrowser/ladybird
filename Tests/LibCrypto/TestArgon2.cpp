/*
 * Copyright (c) 2025, Miguel Sacrist√°n Izcue <miguel_tete17@hotmail.com>
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include <LibCrypto/Hash/Argon2.h>
#include <LibTest/TestCase.h>

// https://www.rfc-editor.org/rfc/rfc9106
TEST_CASE(ARGON2d)
{
    Crypto::Hash::Argon2 argon2(Crypto::Hash::Argon2Type::Argon2d);

    u8 const message[32] = {
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
    };

    u8 const nonce[16] = {
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02
    };

    u8 const secret_value[8] = {
        0x03, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x03, 0x03
    };

    u8 const associated_data[12] = {
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04
    };

    auto const result = TRY_OR_FAIL(argon2.derive_key(
        message,
        nonce,
        4,
        32,
        3,
        0x13,
        TRY_OR_FAIL(ByteBuffer::copy(secret_value, sizeof(secret_value))).span(),
        TRY_OR_FAIL(ByteBuffer::copy(associated_data, sizeof(associated_data))).span(),
        256 / 8));

    u8 const expected_output_key[] = {
        0x51, 0x2b, 0x39, 0x1b, 0x6f, 0x11, 0x62, 0x97,
        0x53, 0x71, 0xd3, 0x09, 0x19, 0x73, 0x42, 0x94,
        0xf8, 0x68, 0xe3, 0xbe, 0x39, 0x84, 0xf3, 0xc1,
        0xa1, 0x3a, 0x4d, 0xb9, 0xfa, 0xbe, 0x4a, 0xcb
    };

    EXPECT_EQ(result.bytes(), ReadonlyBytes(expected_output_key));
}

TEST_CASE(ARGON2i)
{
    Crypto::Hash::Argon2 argon2(Crypto::Hash::Argon2Type::Argon2i);

    u8 const message[32] = {
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
    };

    u8 const nonce[16] = {
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02
    };

    u8 const secret_value[8] = {
        0x03, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x03, 0x03
    };

    u8 const associated_data[12] = {
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04
    };

    auto const result = TRY_OR_FAIL(argon2.derive_key(
        message,
        nonce,
        4,
        32,
        3,
        0x13,
        TRY_OR_FAIL(ByteBuffer::copy(secret_value, sizeof(secret_value))).span(),
        TRY_OR_FAIL(ByteBuffer::copy(associated_data, sizeof(associated_data))).span(),
        256 / 8));

    u8 const expected_output_key[] = {
        0xc8, 0x14, 0xd9, 0xd1, 0xdc, 0x7f, 0x37, 0xaa,
        0x13, 0xf0, 0xd7, 0x7f, 0x24, 0x94, 0xbd, 0xa1,
        0xc8, 0xde, 0x6b, 0x01, 0x6d, 0xd3, 0x88, 0xd2,
        0x99, 0x52, 0xa4, 0xc4, 0x67, 0x2b, 0x6c, 0xe8
    };

    EXPECT_EQ(result.bytes(), ReadonlyBytes(expected_output_key));
}

TEST_CASE(ARGON2id)
{
    Crypto::Hash::Argon2 argon2(Crypto::Hash::Argon2Type::Argon2id);

    u8 const message[32] = {
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
    };

    u8 const nonce[16] = {
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02
    };

    u8 const secret_value[8] = {
        0x03, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x03, 0x03
    };

    u8 const associated_data[12] = {
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04
    };

    auto const result = TRY_OR_FAIL(argon2.derive_key(
        message,
        nonce,
        4,
        32,
        3,
        0x13,
        TRY_OR_FAIL(ByteBuffer::copy(secret_value, sizeof(secret_value))).span(),
        TRY_OR_FAIL(ByteBuffer::copy(associated_data, sizeof(associated_data))).span(),
        256 / 8));

    u8 const expected_output_key[] = {
        0x0d, 0x64, 0x0d, 0xf5, 0x8d, 0x78, 0x76, 0x6c,
        0x08, 0xc0, 0x37, 0xa3, 0x4a, 0x8b, 0x53, 0xc9,
        0xd0, 0x1e, 0xf0, 0x45, 0x2d, 0x75, 0xb6, 0x5e,
        0xb5, 0x25, 0x20, 0xe9, 0x6b, 0x01, 0xe6, 0x59
    };

    EXPECT_EQ(result.bytes(), ReadonlyBytes(expected_output_key));
}
